name: render-report

on:
  workflow_call:
    secrets:
      GH_DASH_REPOS:
        description: 'PAT with repo access for fetching private repository data (optional, falls back to github.token)'
        required: false
    inputs:
      ref:
        description: Git reference or SHA to check out
        required: true
        type: string
      package-list:
        description: R vector of repositories (e.g., c("org/repo1", "org/repo2"))
        required: false
        type: string
        default: ""
      pkg-list-path:
        description: Path to a CSV file with a `repo` column containing repository slugs
        required: false
        type: string
        default: "pkg_list.csv"
      output-subdir:
        description: Subdirectory under report to place the output
        required: false
        type: string
        default: ""
      deploy:
        description: Whether to deploy the rendered report
        required: false
        type: boolean
        default: false
      deploy-target:
        description: Target folder on gh-pages
        required: false
        type: string
        default: ""
      deploy-clean:
        description: Whether to clean the target folder before deploy
        required: false
        type: boolean
        default: false
      deploy-clean-exclude:
        description: Newline-delimited patterns to preserve when cleaning
        required: false
        type: string
        default: ""
      pr-number:
        description: Pull request number (if applicable)
        required: false
        type: string

jobs:
  render:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    env:
      GITHUB_PAT: ${{ secrets.GH_DASH_REPOS || github.token }}
      PACKAGE_LIST: ${{ inputs.package-list }}
      PKG_LIST_PATH: ${{ vars.PKGLISTPATH || inputs.pkg-list-path }}
      OUTPUT_SUBDIR: ${{ inputs.output-subdir }}
      PR_NUMBER: ${{ inputs.pr-number }}
      QUALREPO: ${{ vars.QUALREPO }}
      QUALPATH: ${{ vars.QUALPATH }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          ref: ${{ inputs.ref }}

      - uses: r-lib/actions/setup-pandoc@v2

      - uses: r-lib/actions/setup-r@v2
        with:
          use-public-rspm: true

      - name: Install dependencies
        uses: r-lib/actions/setup-r-dependencies@v2
        with:
          extra-packages: |
            any::rmarkdown
            any::cli
            any::htmltools
            any::gh
            any::remotes

      - name: Install gh.dash from local checkout
        if: ${{ github.repository == 'Gilead-BioStats/gh.dash' }}
        uses: r-lib/actions/setup-r-dependencies@v2
        with:
          extra-packages: |
            local::.

      - name: Install gh.dash from GitHub
        if: ${{ github.repository != 'Gilead-BioStats/gh.dash' }}
        shell: Rscript {0}
        run: |
          remotes::install_github("Gilead-BioStats/gh.dash")

      - name: Fetch qualification registry (sparse checkout)
        if: ${{ env.GITHUB_PAT != '' && env.QUALREPO != '' && env.QUALPATH != '' }}
        id: registry-sparse
        uses: actions/checkout@v5
        with:
          repository: ${{ env.QUALREPO }}
          ref: main
          token: ${{ env.GITHUB_PAT }}
          sparse-checkout: |
            ${{ env.QUALPATH }}
          path: registry

      - name: Count registry rows (sparse checkout)
        if: ${{ env.GITHUB_PAT != '' && env.QUALREPO != '' && env.QUALPATH != '' }}
        shell: bash
        run: |
          set -euo pipefail
          rows=$(($(wc -l < "registry/${QUALPATH}") - 1))
          echo "Rows in registry (sparse): $rows"
          if [ -n "${GITHUB_OUTPUT:-}" ]; then
            echo "registry_rows_sparse=$rows" >> "$GITHUB_OUTPUT"
          fi

      - name: Export registry path for render
        if: ${{ env.GITHUB_PAT != '' && env.QUALREPO != '' && env.QUALPATH != '' }}
        shell: bash
        run: |
          set -euo pipefail
          registry_path="$(pwd)/registry/${QUALPATH}"
          if [ ! -f "$registry_path" ]; then
            echo "Registry CSV not found at $registry_path" >&2
            exit 1
          fi
          echo "GH_DASH_QUAL_REGISTRY_URL=$registry_path" >> "$GITHUB_ENV"

      - name: Render package status report
        shell: Rscript {0}
        run: |
          output_dir <- if (nzchar(Sys.getenv("OUTPUT_SUBDIR"))) {
            file.path("report", Sys.getenv("OUTPUT_SUBDIR"))
          } else {
            "report"
          }
          dir.create(output_dir, recursive = TRUE, showWarnings = FALSE)
          rmarkdown::render(
            input = system.file("report", "package_status_report.Rmd", package = "gh.dash"),
            output_dir = output_dir,
            output_file = "index.html",
            params = list(
              token = Sys.getenv("GITHUB_PAT"),
              title = "BIG",
              packageList = {
                list_env <- Sys.getenv("PACKAGE_LIST", unset = "")
                pkg_list_path <- Sys.getenv("PKG_LIST_PATH", unset = "")
                pkg_list_override <- Sys.getenv("PKGLISTPATH", unset = "")
                if (nzchar(pkg_list_override)) {
                  pkg_list_path <- pkg_list_override
                }
                repos <- if (nzchar(pkg_list_path)) {
                  pkg_file <- file.path(Sys.getenv("GITHUB_WORKSPACE"), pkg_list_path)
                  if (!file.exists(pkg_file)) {
                    stop("Package list CSV not found at ", pkg_file)
                  }
                  read.csv(pkg_file, stringsAsFactors = FALSE)$repo
                } else if (nzchar(list_env)) {
                  eval(parse(text = list_env))
                } else {
                  character(0)
                }
                repos <- as.character(repos)
                repos <- trimws(repos)
                repos <- repos[nzchar(repos)]
                repos
              },
              qualification_registry_url = Sys.getenv("GH_DASH_QUAL_REGISTRY_URL", unset = "")
            )
          )

      - name: Determine deploy folder
        id: deploy-path
        run: |
          if [ -n "$OUTPUT_SUBDIR" ]; then
            echo "value=report/$OUTPUT_SUBDIR" >> "$GITHUB_OUTPUT"
          else
            echo "value=report" >> "$GITHUB_OUTPUT"
          fi

      - name: Deploy to gh-pages
        if: ${{ inputs.deploy }}
        uses: JamesIves/github-pages-deploy-action@v4.5.0
        with:
          branch: gh-pages
          folder: ${{ steps.deploy-path.outputs.value }}
          clean: ${{ inputs.deploy-clean }}
          clean-exclude: ${{ inputs.deploy-clean-exclude }}
          target-folder: ${{ inputs.deploy-target }}

      - name: Comment with PR site URL ðŸŒ
        if: ${{ inputs.pr-number != '' }}
        uses: actions/github-script@v6
        env:
          PR_NUMBER: ${{ inputs.pr-number }}
        with:
          github-token: ${{ github.token }}
          script: |
            const prNumber = process.env.PR_NUMBER;
            if (!prNumber) {
              core.info('No PR number provided; skipping comment.');
              return;
            }

            const prSiteURL = `https://${context.repo.owner}.github.io/${context.repo.repo}/pr/${prNumber}/`;
            const timestamp = new Date().toISOString();
            const commentMarker = 'ðŸŒ PR report preview:';
            const commentBody = `${commentMarker} [${prSiteURL}](${prSiteURL})\n\n_Last updated: ${timestamp}_`;

            const comments = await github.rest.issues.listComments({
              issue_number: Number(prNumber),
              owner: context.repo.owner,
              repo: context.repo.repo,
            });

            const existingComment = comments.data.find(comment =>
              comment.user?.login === 'github-actions[bot]' &&
              comment.body?.includes(commentMarker)
            );

            if (existingComment) {
              await github.rest.issues.updateComment({
                comment_id: existingComment.id,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: commentBody,
              });
            } else {
              await github.rest.issues.createComment({
                issue_number: Number(prNumber),
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: commentBody,
              });
            }
